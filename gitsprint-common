#
# Common functionality
#

# Shell output
warn() { echo "$@" >&2; }
die() { warn "Fatal: $@"; exit 1; }
die_help() { warn $@; flags_help; exit 1; }

escape() {
    echo "$1" | sed 's/\([\.\$\*]\)/\\\1/g'
}

#
# String contains function
# $1 haystack
# $2 Needle
#
contains() {
	local return

	case $1 in
		*$2*)
			return=$FLAGS_TRUE
			;;
		*)
			return=$FLAGS_FALSE
			;;
	esac
	return $return
}

# Basic math
min() { [ "$1" -le "$2" ] && echo "$1" || echo "$2"; }
max() { [ "$1" -ge "$2" ] && echo "$1" || echo "$2"; }

# Basic string matching
startswith() { [ "$1" != "${1#$2}" ]; }
endswith() { [ "$1" != "${1%$2}" ]; }

# Convenience functions for checking shFlags flags
flag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -eq $FLAGS_TRUE ]; }
noflag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -ne $FLAGS_TRUE ]; }

flags_help() {
	eval "$( echo "$OPTIONS_SPEC" | git rev-parse --parseopt -- "-h" || echo exit $? )"
}


#
# Git specific common functionality
# 

git_local_branches() { git for-each-ref --sort refname --format='%(refname:short)' refs/heads; }

git_current_branch() {
	local branch_name

	branch_name="$(git symbolic-ref --quiet HEAD)"
	[ -z $branch_name ] && branch_name="(unnamed branch)" || branch_name="$(git for-each-ref --format='%(refname:short)' $branch_name)"
	echo "$branch_name"
}

git_repo_is_headless() {
	! git rev-parse --quiet --verify HEAD >/dev/null 2>&1
}

git_is_clean_working_tree() {
	git rev-parse --verify HEAD >/dev/null || exit 1
	git update-index -q --ignore-submodules --refresh

	# Check for unstaged changes
	git diff-files --quiet --ignore-submodules || return 1

	# Check for Uncommited changes
	git diff-index --cached --quiet --ignore-submodules HEAD -- || return 2

	return 0
}

git_local_branch_exists() {
	[ -n "$1" ] || die "Missing branch name"
	[ -n "$(git for-each-ref --format='%(refname:short)' refs/heads/$1)" ]
}

git_remote_branch_exists() {
	[ -n "$1" ] || die "Missing branch name"
	[ -n "$(git for-each-ref --format='%(refname:short)' refs/remotes/$1)" ]
}

git_config_bool_exists() {
	local value

	[ -n "$1" ] || die "Missing config option"
	value=$(git config --get --bool $1)
	[ "$value" = "true" ]
}


# gitsprint_override_flag_boolean()
#
# Override a boolean flag
#
# Param $1: string The name of the config variable e.g. "feature.start.fetch"
# Param $2: string The flag name
#
gitsprint_override_flag_boolean() {
	local _variable

	_variable=$(git config --bool --get gitsprint.$1 2>&1)
	case $? in
	0)
		[ "${_variable}" = "true" ] && eval "FLAGS_${2}=${FLAGS_TRUE}" || eval "FLAGS_${2}=${FLAGS_FALSE}"
		;;
	128)
		die "${_variable}"
		;;
	esac
	unset _variable
	return ${FLAGS_TRUE}
}

#
# gitsprint specific common functionality
#

# Functions used to check if the repository is git-sprint enabled
gitsprint_has_master_configured() {
	local master

	master=$(git config --get gitsprint.branch.master)
	[ "$master" != "" ] && git_local_branch_exists "$master"
}

gitsprint_has_development_configured() {
	local development

	development=$(git config --get gitsprint.branch.development)
	[ "$development" != "" ] && git_local_branch_exists "$development"
}

gitsprint_is_initialized() {
	gitsprint_has_master_configured                    && \
	gitsprint_has_development_configured               && \
	[ "$(git config --get gitsprint.branch.master)" != "$(git config --get gitsprint.branch.development)" ] && \
	git config --get-regexp gitsprint.prefix >/dev/null 2>&1
}

#
# Assertions for use in git-sprint subcommands
require_clean_working_tree() {
	local result

	git_is_clean_working_tree
	result=$?
	if [ $result -eq 1 ]; then
		die "Working tree contains unstaged changes. Aborting."
	fi
	if [ $result -eq 2 ]; then
		die "Index contains uncommited changes. Aborting."
	fi
}

#
# Show commands if flag is set.
#
git_do() {
	if flag showcommands; then
		echo "git $@" >&2
	fi

	git "$@"
}