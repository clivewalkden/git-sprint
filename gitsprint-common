#
# Common functionality
#

# Shell output
warn() { echo "$@" >&2; }
die() { warn "Fatal: $@"; exit 1; }
die_help() { warn $@; flags_help; exit 1; }

escape() {
    echo "$1" | sed 's/\([\.\$\*]\)/\\\1/g'
}

#
# String contains function
# $1 haystack
# $2 Needle
#
contains() {
	local return

	case $1 in
		*$2*)
			return=$FLAGS_TRUE
			;;
		*)
			return=$FLAGS_FALSE
			;;
	esac
	return $return
}

# Basic math
min() { [ "$1" -le "$2" ] && echo "$1" || echo "$2"; }
max() { [ "$1" -ge "$2" ] && echo "$1" || echo "$2"; }

# Basic string matching
startswith() { [ "$1" != "${1#$2}" ]; }
endswith() { [ "$1" != "${1%$2}" ]; }

# Convenience functions for checking shFlags flags
flag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -eq $FLAGS_TRUE ]; }
noflag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -ne $FLAGS_TRUE ]; }

flags_help() {
	eval "$( echo "$OPTIONS_SPEC" | git rev-parse --parseopt -- "-h" || echo exit $? )"
}


#
# Git specific common functionality
# 

git_current_branch() {
	local branch_name

	branch_name="$(git symbolic-ref --quiet HEAD)"
	[ -z $branch_name ] && branch_name="(unnamed branch)" || branch_name="$(git for-each-ref --format='%(refname:short)' $branch_name)"
	echo "$branch_name"
}


# gitsprint_override_flag_boolean()
#
# Override a boolean flag
#
# Param $1: string The name of the config variable e.g. "feature.start.fetch"
# Param $2: string The flag name
#
gitsprint_override_flag_boolean() {
	local _variable

	_variable=$(git config --bool --get gitflow.$1 2>&1)
	case $? in
	0)
		[ "${_variable}" = "true" ] && eval "FLAGS_${2}=${FLAGS_TRUE}" || eval "FLAGS_${2}=${FLAGS_FALSE}"
		;;
	128)
		die "${_variable}"
		;;
	esac
	unset _variable
	return ${FLAGS_TRUE}
}